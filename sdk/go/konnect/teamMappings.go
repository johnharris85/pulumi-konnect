// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package konnect

import (
	"context"
	"reflect"

	"github.com/johnharris85/pulumi-konnect/sdk/go/konnect/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Represents the mappings between an external identity provider group and a Konnect team
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/johnharris85/pulumi-konnect/sdk/go/konnect"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			team, err := konnect.NewTeam(ctx, "team", &konnect.TeamArgs{
//				Description: pulumi.String("testing"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = konnect.NewTeamMappings(ctx, "example", &konnect.TeamMappingsArgs{
//				Mappings: konnect.TeamMappingsMappingArray{
//					&konnect.TeamMappingsMappingArgs{
//						Group: pulumi.String("external IdP group"),
//						TeamIds: pulumi.StringArray{
//							team.ID(),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Team mappings can be imported using a proper value of `id` as described above
type TeamMappings struct {
	pulumi.CustomResourceState

	// **(Optional, set{mapping})** Configuration block for a mapping.  Can be specified multiple times for each mapping.  Each block supports the fields documented below.
	Mappings TeamMappingsMappingArrayOutput `pulumi:"mappings"`
}

// NewTeamMappings registers a new resource with the given unique name, arguments, and options.
func NewTeamMappings(ctx *pulumi.Context,
	name string, args *TeamMappingsArgs, opts ...pulumi.ResourceOption) (*TeamMappings, error) {
	if args == nil {
		args = &TeamMappingsArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TeamMappings
	err := ctx.RegisterResource("konnect:index/teamMappings:TeamMappings", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTeamMappings gets an existing TeamMappings resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTeamMappings(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TeamMappingsState, opts ...pulumi.ResourceOption) (*TeamMappings, error) {
	var resource TeamMappings
	err := ctx.ReadResource("konnect:index/teamMappings:TeamMappings", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TeamMappings resources.
type teamMappingsState struct {
	// **(Optional, set{mapping})** Configuration block for a mapping.  Can be specified multiple times for each mapping.  Each block supports the fields documented below.
	Mappings []TeamMappingsMapping `pulumi:"mappings"`
}

type TeamMappingsState struct {
	// **(Optional, set{mapping})** Configuration block for a mapping.  Can be specified multiple times for each mapping.  Each block supports the fields documented below.
	Mappings TeamMappingsMappingArrayInput
}

func (TeamMappingsState) ElementType() reflect.Type {
	return reflect.TypeOf((*teamMappingsState)(nil)).Elem()
}

type teamMappingsArgs struct {
	// **(Optional, set{mapping})** Configuration block for a mapping.  Can be specified multiple times for each mapping.  Each block supports the fields documented below.
	Mappings []TeamMappingsMapping `pulumi:"mappings"`
}

// The set of arguments for constructing a TeamMappings resource.
type TeamMappingsArgs struct {
	// **(Optional, set{mapping})** Configuration block for a mapping.  Can be specified multiple times for each mapping.  Each block supports the fields documented below.
	Mappings TeamMappingsMappingArrayInput
}

func (TeamMappingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*teamMappingsArgs)(nil)).Elem()
}

type TeamMappingsInput interface {
	pulumi.Input

	ToTeamMappingsOutput() TeamMappingsOutput
	ToTeamMappingsOutputWithContext(ctx context.Context) TeamMappingsOutput
}

func (*TeamMappings) ElementType() reflect.Type {
	return reflect.TypeOf((**TeamMappings)(nil)).Elem()
}

func (i *TeamMappings) ToTeamMappingsOutput() TeamMappingsOutput {
	return i.ToTeamMappingsOutputWithContext(context.Background())
}

func (i *TeamMappings) ToTeamMappingsOutputWithContext(ctx context.Context) TeamMappingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamMappingsOutput)
}

func (i *TeamMappings) ToOutput(ctx context.Context) pulumix.Output[*TeamMappings] {
	return pulumix.Output[*TeamMappings]{
		OutputState: i.ToTeamMappingsOutputWithContext(ctx).OutputState,
	}
}

// TeamMappingsArrayInput is an input type that accepts TeamMappingsArray and TeamMappingsArrayOutput values.
// You can construct a concrete instance of `TeamMappingsArrayInput` via:
//
//	TeamMappingsArray{ TeamMappingsArgs{...} }
type TeamMappingsArrayInput interface {
	pulumi.Input

	ToTeamMappingsArrayOutput() TeamMappingsArrayOutput
	ToTeamMappingsArrayOutputWithContext(context.Context) TeamMappingsArrayOutput
}

type TeamMappingsArray []TeamMappingsInput

func (TeamMappingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TeamMappings)(nil)).Elem()
}

func (i TeamMappingsArray) ToTeamMappingsArrayOutput() TeamMappingsArrayOutput {
	return i.ToTeamMappingsArrayOutputWithContext(context.Background())
}

func (i TeamMappingsArray) ToTeamMappingsArrayOutputWithContext(ctx context.Context) TeamMappingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamMappingsArrayOutput)
}

func (i TeamMappingsArray) ToOutput(ctx context.Context) pulumix.Output[[]*TeamMappings] {
	return pulumix.Output[[]*TeamMappings]{
		OutputState: i.ToTeamMappingsArrayOutputWithContext(ctx).OutputState,
	}
}

// TeamMappingsMapInput is an input type that accepts TeamMappingsMap and TeamMappingsMapOutput values.
// You can construct a concrete instance of `TeamMappingsMapInput` via:
//
//	TeamMappingsMap{ "key": TeamMappingsArgs{...} }
type TeamMappingsMapInput interface {
	pulumi.Input

	ToTeamMappingsMapOutput() TeamMappingsMapOutput
	ToTeamMappingsMapOutputWithContext(context.Context) TeamMappingsMapOutput
}

type TeamMappingsMap map[string]TeamMappingsInput

func (TeamMappingsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TeamMappings)(nil)).Elem()
}

func (i TeamMappingsMap) ToTeamMappingsMapOutput() TeamMappingsMapOutput {
	return i.ToTeamMappingsMapOutputWithContext(context.Background())
}

func (i TeamMappingsMap) ToTeamMappingsMapOutputWithContext(ctx context.Context) TeamMappingsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamMappingsMapOutput)
}

func (i TeamMappingsMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*TeamMappings] {
	return pulumix.Output[map[string]*TeamMappings]{
		OutputState: i.ToTeamMappingsMapOutputWithContext(ctx).OutputState,
	}
}

type TeamMappingsOutput struct{ *pulumi.OutputState }

func (TeamMappingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TeamMappings)(nil)).Elem()
}

func (o TeamMappingsOutput) ToTeamMappingsOutput() TeamMappingsOutput {
	return o
}

func (o TeamMappingsOutput) ToTeamMappingsOutputWithContext(ctx context.Context) TeamMappingsOutput {
	return o
}

func (o TeamMappingsOutput) ToOutput(ctx context.Context) pulumix.Output[*TeamMappings] {
	return pulumix.Output[*TeamMappings]{
		OutputState: o.OutputState,
	}
}

// **(Optional, set{mapping})** Configuration block for a mapping.  Can be specified multiple times for each mapping.  Each block supports the fields documented below.
func (o TeamMappingsOutput) Mappings() TeamMappingsMappingArrayOutput {
	return o.ApplyT(func(v *TeamMappings) TeamMappingsMappingArrayOutput { return v.Mappings }).(TeamMappingsMappingArrayOutput)
}

type TeamMappingsArrayOutput struct{ *pulumi.OutputState }

func (TeamMappingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TeamMappings)(nil)).Elem()
}

func (o TeamMappingsArrayOutput) ToTeamMappingsArrayOutput() TeamMappingsArrayOutput {
	return o
}

func (o TeamMappingsArrayOutput) ToTeamMappingsArrayOutputWithContext(ctx context.Context) TeamMappingsArrayOutput {
	return o
}

func (o TeamMappingsArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*TeamMappings] {
	return pulumix.Output[[]*TeamMappings]{
		OutputState: o.OutputState,
	}
}

func (o TeamMappingsArrayOutput) Index(i pulumi.IntInput) TeamMappingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TeamMappings {
		return vs[0].([]*TeamMappings)[vs[1].(int)]
	}).(TeamMappingsOutput)
}

type TeamMappingsMapOutput struct{ *pulumi.OutputState }

func (TeamMappingsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TeamMappings)(nil)).Elem()
}

func (o TeamMappingsMapOutput) ToTeamMappingsMapOutput() TeamMappingsMapOutput {
	return o
}

func (o TeamMappingsMapOutput) ToTeamMappingsMapOutputWithContext(ctx context.Context) TeamMappingsMapOutput {
	return o
}

func (o TeamMappingsMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*TeamMappings] {
	return pulumix.Output[map[string]*TeamMappings]{
		OutputState: o.OutputState,
	}
}

func (o TeamMappingsMapOutput) MapIndex(k pulumi.StringInput) TeamMappingsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TeamMappings {
		return vs[0].(map[string]*TeamMappings)[vs[1].(string)]
	}).(TeamMappingsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TeamMappingsInput)(nil)).Elem(), &TeamMappings{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamMappingsArrayInput)(nil)).Elem(), TeamMappingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamMappingsMapInput)(nil)).Elem(), TeamMappingsMap{})
	pulumi.RegisterOutputType(TeamMappingsOutput{})
	pulumi.RegisterOutputType(TeamMappingsArrayOutput{})
	pulumi.RegisterOutputType(TeamMappingsMapOutput{})
}
